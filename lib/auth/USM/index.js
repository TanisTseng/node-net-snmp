var Constants = require("../constants");
var Exceptions = require("../exceptions");
var TimeWindow = require("../TimeWindow");
var UsmSecurityParameters = require("./usm-security-parameters");

var USM = function(session, options) {
    var config  = session.UsmOptions;

    if (!config) {
        throw new Error('No configuration provided to User-based Security Model.');
    }

    if (!config.auth) {
        config.auth = Constants.AuthTypes.MD5;
    } else if (Constants.AuthTypes.keys().indexOf(config.auth) === -1) {
        throw new Error('Invalid Auth type "' + config.auth + '".');
    }

    if (!options.SecurityName)
        throw new Error('Expected username for the User-based Security Model - none provided.');

    // 3.2 with default no privacy
    if (!this.securityLevel & Constants.BitwiseFlags.Priv) {
        options.privModel = 'plain';
    } else if (!config.privModel) {
        throw new Error('Privacy requested, without privacy parameters!');
    } else if (Constants.PrivTypes.indexOf(config.privModel) === -1) {
        throw new Exceptions.UnsupportedSecurityLevel(
            'Unsupported Privacy type: "' + config.privModel + '"'
        );
    }

    // 3.3
    if (Constants.AuthTypes.indexOf(config.authModel) === -1) {
        throw new Exceptions.UnsupportedSecurityLevel(
            'Unsupported Authentication type: "' + config.authModel + '"'
        );
    }

    this.session = session;
    this.config  = config;
    this.securityEngineId = options.securityEngineId;
    this.securityName  = options.securityName;
    this.securityLevel = options.securityLevel;
};

USM.prototype.generateRequestMessage = function(scopedPDU) {
    return this.generateResponseMessage(scopedPDU, null);
};

USM.prototype.generateResponseMessage = function(scopedPDU, securityStateReference) {
    var securityParameters = new UsmSecurityParameters,
        must_encrypt = this.securityLevel & Constants.BitwiseFlags.Priv,
        must_authenticate = this.securityLevel & Constants.BitwiseFlags.Auth;

    if (securityStateReference !== null) {
        // securityStateReference not checked as we are not responding to a request
        //  If we were responding to a request, securityStateReference would refer
        //  to the cached data generated by this module when processing the
        //  incoming message.                   --- 3.1.1(a)
        throw new Error("Not implemented");
    } else if (false != this.securityName) {
        // Should be pulled from the LCD
        // The compound keys of SecurityName and SecurityEngineId are used
        //  to find the authetication and encryption parameters.

        usmUserEngineID         SnmpEngineID,
        usmUserName             SnmpAdminString,
        usmUserSecurityName     SnmpAdminString,
        usmUserCloneFrom        RowPointer,
        usmUserAuthProtocol     AutonomousType,
        usmUserAuthKeyChange    KeyChange,
        usmUserOwnAuthKeyChange KeyChange,
        usmUserPrivProtocol     AutonomousType,
        usmUserPrivKeyChange    KeyChange,
        usmUserOwnPrivKeyChange KeyChange,
        usmUserPublic           OCTET STRING,
        usmUserStorageType      StorageType,
        usmUserStatus           RowStatus

        // Currently, we just use the settings provided by this.config.
        var {
            usmUserName: usmUserName,
            usmUserAuthProtocol: usmUserAuthProtocol,
            usmUserPrivProtocol: usmUserPrivProtocol,
        } = {
            usmUserEngineID: this.securityEngineId,
            usmUserName: this.securityName,
            usmUserSecurityName: this.securityName,
            usmUserCloneFrom: '0.0',
            usmUserAuthProtocol: this.config.authModel,
            usmUserAuthKeyChange: '',
            usmUserOwnAuthKeyChange: '',
            usmUserPrivProtocol: this.config.privModel,
            usmUserPrivKeyChange: '',
            usmUserOwnPrivKeyChange: '',
            usmUserPublic: '',
            usmUserStorageType: Constants.StorageType.readOnly,
            usmUserStatus: undefined        // Don't know what to set it to... It's not important here anyway.
        };

        /**
         * Localize Auth and Priv keys
         */
        var usmUserAuthKeyLocalized = null,
            usmUserPrivKeyLocalized = null;
    } else {
        // This is not a response and we don't have a securityName.
        // Begin engineID discovery.
        var usmUserName = null,
            usmUserSecurityName = null,
            usmUserAuthProtocol = noAuth,
            usmUserPrivProtocol = noPriv,
            usmUserAuthKeyLocalized = '',
            usmUserPrivKeyLocalized = '';
    }

    // 3.4 - encryption
    if (must_encrypt) {
        // 3.4(a)
        scopedPDU = this._performEncryption(scopedPDU, usmUserPrivKeyLocalized, securityParameters);
    } else {
        // 3.4(b)
        securityParameters.msgPrivacyParameters = '';
    }

    // 3.5
    securityParameters.msgAuthoritativeEngineId = this.engineId;

    // 3.6
    if (must_authenticate) {
        // 3.6(a) - Authenticate
        securityParameters.msgAuthoritativeEngineBoots = this.timeWindow.getBoots();
        securityParameters.msgAuthoritativeEngineTime  = this.timeWindow.getTime();
    } else if (this.securityStateReference !== null) {
        // 3.6(b) - Response
        // use local engine time and boots
    } else {
        // 3.6(c) - Request
        securityParameters.msgAuthoritativeEngineBoots = 0;
        securityParameters.msgAuthoritativeEngineTime  = 0;
    }

    // 3.7
    securityParameters.msgUserName = this.username;

    // 3.8 - authentication
    if (must_authenticate) {
        // 3.8(a)
        this._performAuthentication(scopedPDU, usmUserAuthKeyLocalized, securityParameters);
    } else {
        // 3.8(b)
        securityParameters.msgAuthenticationParameters = '';
    }

    return true;
};

USM.prototype._localizeKey = function() {
    // password?
    // Ku = password
    // Kul = {Ku}{EngineID}{Ku}
    // find auth protocol for user@engine (MD5/SHA1)
    // return auth->hash(Kul)
};

USM.prototype._performEncryption = function(scopedPDU, key, securityParameters) {
    switch (this.config.privModel) {
        // ..
    }

    // ->                                       key,       pdu
    var encryption = new this[encryptionModule](key, scopedPDU);

    if (!encryption.statusInformation) {
        throw new Exceptions.EncryptionError("The encryption mechanism failed.");
    }

    securityParameters.msgPrivacyParameters = encryption.privParameters;
    return encryption.encryptedData;
};

USM.prototype._performAuthentication = function(scopedPDU, key, securityParameters) {
    throw new Error('Not yet implemented');

    var params = auth.authenticateOutgoingMsg(key, scopedPDU);

    if (!auth.statusInformation) {
        throw new Exceptions.AuthenticationFailure("The message could not be authenticated.");
    }

    securityParameters.msgAuthenticationParameters = authentication.authenticatedWholeMsg;
};

module.exports = USM;
