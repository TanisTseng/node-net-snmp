var Constants = require("../../../constants");
var Exceptions = require("../../../exceptions");
var TimeWindow = require("../../TimeWindow");
var UsmSecurityParameters = require("./usm-security-parameters");
var HMAC_MD5_96 = require("./authentication/md5");
var HMAC_SHA_96 = require("./authentication/sha");

var USM = function(session, options) {
    var config  = session.UsmOptions;

    if (!config) {
        throw new Error('No configuration provided to User-based Security Model.');
    }

    if (!options.SecurityName)
        throw new Error('Expected username for the User-based Security Model - none provided.');

    // 3.2 with default no privacy
    if (!this.securityLevel & Constants.BitwiseFlags.Priv) {
        options.privModel = 'plain';
    } else if (!config.privModel) {
        throw new Error('Privacy requested, without privacy parameters!');
    } else if (Constants.PrivTypes.indexOf(config.privModel) === -1) {
        throw new Exceptions.UnsupportedSecurityLevel(
            'Unsupported Privacy type: "' + config.privModel + '"'
        );
    }

    // 3.3
    if (Constants.AuthTypes.indexOf(config.authModel) === -1) {
        throw new Exceptions.UnsupportedSecurityLevel(
            'Unsupported Authentication type: "' + config.authModel + '"'
        );
    }

    config.authKey = config.authKey || '';
    config.privKey = config.privKey || '';

    this.session = session;
    this.config  = config;
    this.securityEngineId = options.securityEngineId;
    this.securityName  = options.securityName;
    this.securityLevel = options.securityLevel;
};

USM.prototype.generateRequestMessage = function(scopedPDU) {
    return this.generateResponseMessage(scopedPDU, null);
};

USM.prototype.generateResponseMessage = function(scopedPDU, securityStateReference) {
    var securityParameters = new UsmSecurityParameters,
        must_encrypt = this.securityLevel & Constants.BitwiseFlags.Priv,
        must_authenticate = this.securityLevel & Constants.BitwiseFlags.Auth,
        authModel = null,
        privModel = null;

    if (securityStateReference !== null) {
        // securityStateReference not checked as we are not responding to a request
        //  If we were responding to a request, securityStateReference would refer
        //  to the cached data generated by this module when processing the
        //  incoming message.                   --- 3.1.1(a)
        throw new Error("Not implemented");
    } else if (false != this.securityName) {
        // Should be pulled from the LCD
        // The compound keys of SecurityName and SecurityEngineId are used
        //  to find the authetication and encryption parameters.

        // Currently, we just use the settings provided by this.config.
        var {
            usmUserName: usmUserName,
            usmUserAuthProtocol: usmUserAuthProtocol,
            usmUserPrivProtocol: usmUserPrivProtocol,
        } = {
            usmUserEngineID: this.securityEngineId,
            usmUserName: this.securityName,
            usmUserSecurityName: this.securityName,
            usmUserCloneFrom: '0.0',
            usmUserAuthProtocol: this.config.authModel,
            usmUserAuthKeyChange: '',
            usmUserOwnAuthKeyChange: '',
            usmUserPrivProtocol: this.config.privModel,
            usmUserPrivKeyChange: '',
            usmUserOwnPrivKeyChange: '',
            usmUserPublic: '',
            usmUserStorageType: Constants.StorageType.readOnly,
            usmUserStatus: undefined        // Don't know what to set it to... It's not important here anyway.
        };

        authModel = this._getAuthModel(usmUserAuthProtocol);
        privModel = this._getPrivModel(usmUserPrivProtocol);

        /**
         * Localize Auth and Priv keys
         */
        var usmUserAuthKeyLocalized = null,
            usmUserPrivKeyLocalized = null;
    } else {
        // This is not a response and we don't have a securityName.
        // Begin engineID discovery.
        var usmUserName = null,
            usmUserSecurityName = null,
            usmUserAuthProtocol = noAuth,
            usmUserPrivProtocol = noPriv,
            usmUserAuthKeyLocalized = '',
            usmUserPrivKeyLocalized = '';
    }

    // 3.4 - encryption
    if (must_encrypt) {
        // 3.4(a)
        scopedPDU = this._performEncryption(scopedPDU, usmUserPrivKeyLocalized, securityParameters);
    } else {
        // 3.4(b)
        securityParameters.msgPrivacyParameters = '';
    }

    // 3.5
    securityParameters.msgAuthoritativeEngineId = this.engineId;

    // 3.6
    if (must_authenticate) {
        // To come from the LCD
        // 3.6(a) - Authenticate
    } else if (this.securityStateReference !== null) {
        // 3.6(b) - Response
        securityParameters.msgAuthoritativeEngineBoots = this.timeWindow.getBoots();
        securityParameters.msgAuthoritativeEngineTime  = this.timeWindow.getTime();
    } else {
        // 3.6(c) - Request
        securityParameters.msgAuthoritativeEngineBoots = 0;
        securityParameters.msgAuthoritativeEngineTime  = 0;
    }

    // 3.7
    securityParameters.msgUserName = this.username;

    // 3.8 - authentication
    if (must_authenticate) {
        // 3.8(a)
        this._performAuthentication(scopedPDU, usmUserAuthKeyLocalized, securityParameters);
    } else {
        // 3.8(b)
        securityParameters.msgAuthenticationParameters = '';
    }

    return {
        statusInformation: true,
        securityParameters: securityParameters
    };
};

USM.prototype._getAuthModel = function(protocol) {
    var model = null;

    switch (protocol) {
        case Constants.AuthTypes.MD5:
            model = new HMAC_MD5_96;
            break;
        case Constants.AuthTypes.SHA:
            model = new HMAC_SHA_96;
            break;
        case 'plain':
        default:
            throw new Error.UnsupportedSecurityLevel('Unsupported Authentication Type: ' + protocol);
    }

    return model;
};

USM.prototype._getPrivModel = function(protocol) {
    var model = null;

    switch (protocol) {
        case Constants.PrivTypes.DES:
//            model = new *DES*;
            break;
        case 'plain':
        default:
            throw new Error.UnsupportedSecurityLevel('Unsupported Privacy Type: ' + protocol);
    }

    return model;
};

USM.prototype._localizeKey = function(hash, password) {
    return hash.localizeKey(hash.hashPassphrase(password), this.securityEngineId);
};

USM.prototype._performEncryption = function(scopedPDU, key, securityParameters) {
    switch (this.config.privModel) {
        // ..
    }

    // ->                                       key,       pdu
    var encryption = new this[encryptionModule](key, scopedPDU);

    if (!encryption.statusInformation) {
        throw new Exceptions.EncryptionError("The encryption mechanism failed.");
    }

    securityParameters.msgPrivacyParameters = encryption.privParameters;
    return encryption.encryptedData;
};

USM.prototype._performAuthentication = function(scopedPDU, key, securityParameters) {
    throw new Error('Not yet implemented');

    var params = auth.authenticateOutgoingMsg(key, securityParameters);

    if (!auth.statusInformation) {
        throw new Exceptions.AuthenticationFailure("The message could not be authenticated.");
    }

    securityParameters.msgAuthenticationParameters = auth.authParameters;
};

module.exports = USM;
